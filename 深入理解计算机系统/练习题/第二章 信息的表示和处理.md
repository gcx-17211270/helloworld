# 第二章 信息的表示和处理

## 练习题2.1

    A. 0011 1001 1010 0111 1111 1000
    B. C97B
    C. 1101 0101 1110 0100 1100
    D. 26E7B5

## 练习题2.5

    A. 小端：21 大端：87
    B. 21 43；      87 65
    C. 21 43 65;    87 65 43

## 练习题2.6

打印出来的数据分别是 3510593 = 41913500， 3510593.0 = 0445564a，考虑到电脑是小端机器，则正确的顺序及二进制表示如下所示

    00359141 = 00000000001101011001000101000001
      4a564504 = 01001010010101100100010100000100

对齐后，有21位是相同的。

## 练习题2.7

输出的结果是616263646566，由于char类型的只占一个字节，因而他们不涉及高低字节保存的问题，打印出来的数据就是他们对应字符的ASCII码顺序排列。

## 练习题2.8

    ~a: 10010110
    ~b: 10101010
    a&b:01000001
    a|b:01111101
    a^b:00111100

## 练习题2.9

    A. 黑-白 蓝-黄 绿-红紫 蓝绿-红色
    B.  011 蓝绿色
        010 绿色
        001 蓝色

## 练习题2.10

    第一步：x = a               y = a ^ b
    第二步：x = a ^ (a ^ b) = (a ^ a) ^ b = 0 ^ b
            y = a ^ b
    第三步：x = b               y = b ^ (a ^ b) = a

## 练习题2.11

    A. first = last = k
    B. 自身与自身异或结果为0
    C. 将first <= last 改为 first < last, 不改动中间的值

## 练习题2.12

    A. x &= 0xFF;
    B. x ^= (~0xFF)
    C. x |= 0xFF;

## 练习题2.13

根据提示，我们可以写出bis的C语言表达式，bis(x,y) = x | y; bic(x, y) = x & (~y);那么，根据异或的真值表，我们可以写出，x^y = x&(~y) | y&(~x)，写成bis,bic指令，即得到结果。

    bool_or:
        int result = bis(x, y);
    bool_xor:
        int result = bis(bic(x, y), bic(y, x));

## 练习题2.14

x = 0x66        0b 0110 0110
y = 0x39        0b 0011 1001

表达式|值||表达式|值
:-:|:-:|:-:|:-:|:-:
x & y|0x20|&emsp;&emsp;&emsp;|x&&y|1
x \| y|0x7F|&emsp;&emsp;&emsp;|x \|\| y|1
~x \| ~y|0xDF|&emsp;&emsp;&emsp;|!x \|\| !y|0
x & !y|0|&emsp;&emsp;&emsp;|x&&~y|1

## 练习题2.15

```C

int bit_add(int x, int y)
{
    //只用位级和逻辑运算，编写一个判断x==y
    return !(x^y);
}

```

## 练习题2.16

x 十六进制|x 二进制|x<<3|&emsp;|x>>2逻辑|&emsp;|x>>2算术|
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
0xC3|0b 1100 0011|0b 0001 1000|0x18|0b 0011 0000|0x30|0b 1111 0000|0xF0
0x75|0b 0111 0101|0b 1010 1000|0xA8|0b 0001 1101|0x1D|0b 0001 1101|0x1D
