# 第二章 信息的表示与处理

`
二进制的表示、存储和传输对于存储和机器处理信息，显得更加便利，但是孤立的位并没有意义，我们必须对其赋予一定的说明（interpretation），我们才能表示一个二进制数字系统。本章的内容，便是建立如此的二进制数字系统。
`

## 2.1 信息存储

### 2.1.1 十六进制表示法、字、数据大小

&emsp;&emsp;二进制的表示通常太长而难以使用，我们用十六进制数(hexadecimal)来表示位模式。在C语言中，以0x或0X开头的数字常量被认为是十六进制数。十六进制数与二进制数的转换很容易，对于十六进制的一位数，我们可以用四位二进制数来表示，而对于二进制数，我们可以通过高位补零让其成为几组十六进制数的组合。

&emsp;&emsp;字长(word size)是计算机一次能处理的数据的位数，也是计算机内部各种通用寄存器的位数。对于字长为w的机器而言，虚拟地址的范围为0~2^(w)-1，程序最多访问2^w字节的数据范围。

C语言中的数据大小：

<center>

数据类型|32位机器|32位数据范围|64位机器表示|64位数据范围
:-:|:-:|:-:|:-:|:-:
char|1|-128~127|1|-128~127
short int|2|-32768~32767|2|-32768~32767
int|4|-2147483648~2147483647|4|-2147483648~2147483647
unsigned int|4|0-4294967295|4|0-4294967295
long int|4|-2147483648~2147483647|8|-x~x-1 x=9223372036854775808
long long int|8|-x~x-1 x=9223372036854775808|8|-x~x-1 x=9223372036854775808
char*|4|指针范围即地址范围|8|指针范围即地址范围
float|4|浮点数使用IEEE754标准，与整数不同|4|浮点数使用IEEE754标准，与整数不同
double|8|浮点数使用IEEE754标准，与整数不同|8|浮点数使用IEEE754标准，与整数不同
</center>

### 2.1.2 寻址，大小端

> 对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么、在存储器中如何排列这些字节。在几乎所有的机器中，多字节对象被存储为连续的字节序列，对象的地址即为所使用字节中最小的地址。

上面的话体现了我们在计算机中存储数据时候要考虑到的基本问题，就是数据存放到哪儿以及如何存放，如何存放即为大小端的问题，考虑排列一个w位的整数，我们在计算机中是按字节存放这个整数的各个位，如果将数据的低位存放到低地址高位存放到高地址，或者说低位在前而高位在后，则为小端法(little endian)，否则则为大端法(big endian)。

考虑存储一个十六进制数0x01234567,存储的起始地址为0x100。小端法先存低位数字，大端法先存高位数字，则存储的地址与内容如下所示：

```C
    ……  0x100   0x101   0x102   0x103   ……
小端 …… 67      45      23      01  
大端 …… 01      23      45      67
```

### 2.1.3 show_bytes.c，打印示例数据对象的字节表示

C语言知识：```typedef int *int_pointer;```使用它命名数据类型，以后就可以用int_pointer来表示int*，稍微复杂一点的```typedef int Matrix[M][N]```那么以后就可以使用Matrix来表示一个M*N的整数矩阵的数据结构

使用本程序(在练习题中有源文件)可以打印出数据在计算机中的存放顺序

### 2.1.4 字符串表示

常用的英文字符及一些特殊字符可以被编为ASCII码，使用一个字节即可存放。但对于其他特殊字符我们使用Unicode文字编码，更长的码字可以表示几乎所有语言的符号。

### 2.1.5 二进制代码在不同操作系统上是不兼容的

在计算机中，C程序被编译为二进制代码进而执行，由于各个操作系统下使用不同的指令集，生成的二进制代码是不同的，因此**二进制代码是不兼容的**

### 2.1.6 布尔代数，与、或、非、异或

1850年，布尔(George Boole, 1815-1864)注意到将逻辑值TRUE、FALSE编码为1和0，能够设计出一种代数，以研究逻辑推理的基本原理。称为布尔代数(Bool algebra)。

后来创立信息理论的Claude Shannon(1916-2001)首先分析了布尔代数与数字逻辑之间的联系，1937年，他在硕士论文中表明了布尔代数可以用来设计和分析机电继电器网络。布尔代数在数字系统的设计和分析中扮演着重要的角色。

### 2.1.7 C语言位级运算、掩码运算

<html>
<body>
    <h2>2.2 整数运算</h2>
    <p style="text-indent:2em" >在本节中，我们要使用位来编码整数的两种不同的方式：一种只能表示非负数，而另一种能够用来表示负数、零和正数。后面我们将看到他们的数学属性和机器级实现方面密切关联。我们也会研究扩展或收缩一个已编码整数以适应不同长度表示的效果。</p>
    <h3>2.2.1 整型数据类型</h3>
    <h3>2.2.2 无符号数的编码</h3>
    <p style="text-indent:2em">B2Uw(Binary to Unsigned) w是位宽</p>
    <h3>2.2.3 补码编码</h3>
    <p style="text-indent:2em">补码(two's-complement) B2Tw(Binary to Two's-complement)</p>
    <p style="text-indent:2em">C语言标准没有要求用补码形式表示有符号整数，但是几乎所有的机器表示都是这么做的，程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，那么就应该注意有符号数在指定位数机器下补码的有效范围。</p>
    <p style="text-indent:2em">典型的，C库文件&lt; limits.h &gt;中定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围。比如它定义了常量INT_MAX,INT_MIN, UINT_MAX，他们描述了有符号数和无符号数的表示范围。为了确定整数的位数，IOS C99标准在stdint.h中引入了另一类整数类型。这个文件定义了一组数据类型，他们的声明形如intN_t，这样我们就能比较容易的判断数据的位数</p>
    <p style="text-indent:2em">关于整数数据的取值范围和表示，Java标准是明确的，他要求采用补码表示。</p>
    <h3>2.2.4 有符号数和无符号数之间的转换</h3>
    <p style="text-indent:2em">强制类型转换的结果保持位值不变，只是改变了解释这些位的方式（运行show_bytes 63-83行的程序可以证明这一点）</p>
    <h3>2.2.6 扩展一个数字的位表示</h3>
    <p style="text-indent:2em">一种常见的运算是在不同的字长的整数之间转换，同时又保持数值不变。将一个无符号数转换为一个更大的数据类型时，我们只要简单地在开头添加0，这种运算称为零扩展(zero extension)。将一个补码数字转换位一个更大的数据类型时，我们需要在前面添加最高有效位的副本，这样的运算称为符号扩展(sign extension)</p>
    <h3>2.2.7 截断数字</h3>
    <p style="text-indent:2em">假设我们不采用额外的位来扩展一个数值，而是减少表示一个数字的位数，数字在内存中的内容将会被截断。</p>
    <h3>2.2.8 关于有符号数和无符号数的建议</h3>
    <p style="text-indent:2em">有符号数到无符号数的隐式强制转换可能导致某些非直观的行为，这些非直观的特性经常导致程序出错，并且这种包含隐式强制类型转换细微差别的错误很难被发现。</p>
</body>
</html>

## 一点计算机网络的知识：一个数据包的结构

<html>
<body>
<table border="2">
    <tr>
        <th colspan="3">数据链路层<br>以太网首部</th>
        <th colspan="3">网络层<br>IP首部</th>
        <th colspan="3">传输层<br>TCP首部</th>
        <th colspan="3">会话层<br>表示层<br>应用层</th>
        <th colspan="3">数据链路层</th>
    </tr>
    <tr>
        <td>接收端<br>MAC地址</td>
        <td>发送端<br>MAC地址</td>
        <td>以太网类型</td>
        <td>发送端<br>IP地址</td>
        <td>接受端<br>IP地址</td>
        <td>协议类型</td>
        <td colspan="1.5">源端口号</td>
        <td colspan="1.5">目的端口号</td>
        <td colspan="4">数据</td>
        <td colspan="3">循环冗余校验</td>
    </tr>
</table>  
</body>
</html>
