# 199. 二叉树的右视图

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]

输出: [1, 3, 4]

解释:

```文本
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

通过次数40,089提交次数63,045

## 题解0 从右边的递归算法，找到的是右子树的最外圈，不符合题目要求

- 状态：解答错误

&emsp;&emsp;154 / 211 个通过测试用例

- 输入：[1,2,3,4]

- 输出：[1,3]

- 预期：[1,3,4]
  
## 题解1 BFS，广度优先搜索

层级遍历，记录下每层的最后一个元素

- 执行结果：通过
- 执行用时 :1 ms, 在所有 Java 提交中击败了97.32%的用户
- 内存消耗 :38.1 MB, 在所有 Java 提交中击败了5.00%的用户
- 复杂度分析：<br/>
&emsp;&emsp;&ensp;时间复杂度 : O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。<br/>
&emsp;&emsp;&ensp;空间复杂度 : O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。

## 题解2 运行速度快

明明和3没什么区别……

## 题解3 DFS，深度优先搜索 

我们按照 「根结点 -> 右子树 -> 左子树」 的顺序访问， 就可以保证每层都是最先访问最右边的节点的。

（与先序遍历 「根结点 -> 左子树 -> 右子树」 正好相反，先序遍历每层最先访问的是最左边的节点）

- 执行结果：通过
- 执行用时 :1 ms, 在所有 Java 提交中击败了97.32%的用户
- 内存消耗 :38.3 MB, 在所有 Java 提交中击败了5.00%的用户
- 复杂度分析：<br/>
&emsp;&emsp;&ensp;时间复杂度 : O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。<br/>
&emsp;&emsp;&ensp;空间复杂度 : O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。