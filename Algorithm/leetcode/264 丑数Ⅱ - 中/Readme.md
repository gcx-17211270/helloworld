<!--
 * @Descripttion: 
 * @version: 
 * @Author: 32353
 * @Date: 2021-04-11 12:01:39
 * @LastEditors: 32353
 * @LastEditTime: 2021-04-11 12:01:51
-->

# 264 丑数Ⅱ

## 1.暴力循环判断

逐个的判断每个数是否是符合条件，当个数达到则返回

<pre>
500 / 596 个通过测试用例
状态：超出时间限制
最后执行的输入：1352
</pre>

## 2.稍优化的暴力判断

对于上面的进行稍微优化，存储已经判断出来的丑数，当判断中再次遇到就不必判断到底

尴尬的是在结果反而变差了，看来对于数组太多的contains()调用，导致算法的复杂度增加甚至超过了存储判断的优势

<pre>
258 / 596 个通过测试用例
状态：超出时间限制
最后执行的输入：259
</pre>

在本地IDE上，获得第1000个数花费了770419ms

## 3.对于从2、3、5出发，寻找他们乘积第n大的数

执行结果：通过

执行用时：1088 ms, 在所有 Java 提交中击败了5.04%的用户

内存消耗：38.5 MB, 在所有 Java 提交中击败了5.16%的用户
