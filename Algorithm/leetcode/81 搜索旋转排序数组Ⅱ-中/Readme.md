<!--
 * @Descripttion: 
 * @version: 
 * @Author: 32353
 * @Date: 2021-04-10 09:01:40
 * @LastEditors: 32353
 * @LastEditTime: 2021-04-10 09:01:42
-->

# 81.寻找旋转排序数组Ⅱ

## 1.想到根据数据两端大小关系，判断二分得到的左、右侧是否为有序数组，对于是的一侧使用简单的二分查找，另一侧继续二分判断

忽略了数组中有重复元素，我大意了啊，没有闪。这样对于含有重复元素的结果是会产生极大的误判，但还好至少通过了一些的测试用例。

<pre>
搜索旋转排序数组 II
提交记录
224 / 279 个通过测试用例
状态：解答错误
提交时间：几秒前
输入：
[1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1]
2
输出：false
预期：true
</pre>

## 2.对上面的稍微修改了一下。

如果可以根据大小关系直接判断有序，则使用上面的方法。如果因为重复元素不能判断是否有序，则判断数组最后一个元素是否符合条件，如果不符合，则数组长度减一，继续判断。换句话说，这样做很容易复杂度O(N)，加上递归的内存占用，可能还没遍历效果好。

感觉就是在修修补补中添加了太多的判断条件，判断越多就越容易出错。

执行结果：通过

执行用时：19 ms, 在所有 Java 提交中击败了5.33%的用户

内存消耗：38.4 MB, 在所有 Java 提交中击败了13.51%的用户

贴个直接遍历的(手动捂脸)：

执行用时：1 ms, 在所有 Java 提交中击败了86.35%的用户

内存消耗：37.9 MB, 在所有 Java 提交中击败了99.06%的用户
