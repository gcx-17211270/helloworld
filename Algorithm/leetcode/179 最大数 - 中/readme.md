<!--
 * @Descripttion: 
 * @version: 
 * @Author: 32353
 * @Date: 2021-04-12 10:45:03
 * @LastEditors: 32353
 * @LastEditTime: 2021-04-12 11:12:55
-->

# 179 最大数

## 1.将所有整数内容都除以10，得到一个不大于1的小数，例如9是0.9，1是0.1，这样根据这个值的大小，我们就可以判断出这些数字应该以怎样的顺序组合

但是这样有一个问题，就是1和10的结果是一样的，但实际上1的优先级显然大于10；而且在插入图中会覆盖掉一个值，所以会导致解答错误

<pre>
152 / 229 个通过测试用例
状态：解答错误
输入：
[3,30,34,5,9]
输出：
"953430"
预期：
"9534330"
</pre>

## 2.对上面的思路进行优化，key的值包含了小数部分，还有除的时候的位数，然后再判断组合顺序

<pre>
180 / 229 个通过测试用例
状态：解答错误
提交时间：几秒前
输入：
[111311, 1113]
输出：
"1113111113"
预期：
"1113111311"
</pre>

emm，这就不是优化能解决的了，看来是思路还得调整调整

## 3.重写比较方法，根据(o1, o2)->(o2 + o1).compareTo(o1 + o2)的方法进行排序

这样是不是就有种，那个“局部最优则最后得到全局最优”的意思了

<pre>
229 / 229 个通过测试用例
状态：通过
执行用时: 6 ms
内存消耗: 37.7 MB
</pre>

来源:https://leetcode-cn.com/problems/largest-number/comments/68190

## 4.根据3的思路，自己写排序算法（以冒泡排序为例）

<pre>
执行用时：27 ms
内存消耗：38.4 MB
</pre>
