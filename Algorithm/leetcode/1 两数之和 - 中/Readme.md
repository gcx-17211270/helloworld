# 1. 两数之和

## 题目描述

```NULL
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
```

## 示例

```NULL
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
通过次数1,420,311       提交次数2,872,230
```

## 题解

## 1_00.c 暴力循环

    暴力循环，直接求解，使用两重循环，分别找到第一个数与符合要求的第二个数

### 复杂度分析：

- 时间复杂度：O(n²)

对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n²)

- 空间复杂度：O(1)。

执行用时: 220 ms&emsp;&emsp;内存消耗: 5.8 MB

## 1_01.c 暴力循环

    暴力循环同理，但是第二次寻找符合条件的第二个数时，采用一次减法，然后判断相等

    不用每次都求和，可以稍微减少一下执行时间

### 复杂度分析：

- 时间复杂度：O(n²)

对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n²)

- 空间复杂度：O(1)。

执行用时: 136 ms&emsp;&emsp;内存消耗: 5.9 MB

## 1_1.c 一次哈希表

```NULL
    作者：jyding
    链接：https://leetcode-cn.com/problems/two-sum/solution/cyu-yan-ji-yu-shu-zu-de-san-lie-15xing-dai-ma-8ms-/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

没必要使用C语言实现hash操作，直接使用数组进行散列， 即将 nums 中的元素值当下标，nums的下标当值存储在hash 数组中 ： hash[ nums[i] ] = i;

    1.首先初始化 hash[2000], 初始值设为 -1
    2.遍历数组， 查看 target - nums[i] 为下标 的 hash 数组元素值 (hash[ target - nums[i] ]) 是否为 - 1;
        若为 -1 ，将 下标 i 存放在 hash数组的 nums[i] 位置上， hash[ nums[i] ] = i;
        若不为 -1 ，即存在 相加为 target 的元素，两个元素的下标为 hash[ target - nums[i]] , i;
    3.注意：测试用例中存在负数，在散列时会访问越界，故使用求余法，将负数散列到数组尾部 : hash[(nums[i] + MAX_SIZE) % MAX_SIZE] = i; 查找时也要如此；    就是负数放到后面

说明一下：这种方法局限性在数组长度和散列函数上，容易导致hash散列冲突；

我所知道的就是：
    1.构造更好的散列函数，但冲突不可避免,
    2.使用开放定址法或拉链法处理冲突;

但就我做这题时官方测试用例而言，这种方法能够通过。所以具体问题咱们具体分析。

### 复杂度分析：

- 时间复杂度：O(n)

    对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n²)

- 空间复杂度：O(n)。
执行用时: 8 ms&emsp;&emsp;内存消耗: 6 MB

## 1_2.c 两遍哈希表

```
作者：chen-xing-15
链接：https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-san-chong-jie-fa-by-chen-xing-15/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

&emsp;&emsp;为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。

&emsp;&emsp;通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。

&emsp;&emsp;一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！

&emsp;&emsp;c中没有hashMap的实现,因此需要自己手动实现一个.

### 复杂度分析

- 时间复杂度：O(n)，
    我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。

- 空间复杂度：O(n)，
    所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。

执行用时: 8 ms&emsp;&emsp;内存消耗: 6.8 MB
