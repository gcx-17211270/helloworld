# 589. N叉树的前序遍历

给定一个 N 叉树，返回其节点值的前序遍历。

例如，给定一个 3叉树 :

[图片见原网页](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

返回其前序遍历: [1,3,5,6,2,4]。

说明: 递归法很简单，你可以使用迭代法完成此题吗?

通过次数23,917&emsp;&emsp;&emsp;&emsp;提交次数32,836

## 题解0 Java的递归解法

- 执行结果：通过
- 执行用时 :1 ms, 在所有 Java 提交中击败了98.72%的用户
- 内存消耗 :41 MB, 在所有 Java 提交中击败了16.67%的用户
- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度：所有节点都被遍历到 O(N)
<br/>&emsp;&emsp;空间复杂度：使用Node遍历了所有节点，即O(N)

## 题解1 Java的非递归解法

所谓递归实际是调用了隐式栈 所以转换成迭代也仅仅需要把栈显式化罢了,非递归解题思路：

    1.二叉树的非递归遍历是每次将当前结点右孩子节点和左孩子节点依次压入栈中，注意是先右后左。
    2.然后将出栈节点输出，并且在将其右子节点和左子节点压入栈中。
    3.推广到N叉树，就是将当前结点的孩子节点由右到左依次压入栈中。
    4.然后将出栈节点输出，并且将其孩子节点依次压入栈中。

- 执行结果：通过
- 执行用时 :1 ms, 在所有 Java 提交中击败了98.72%的用户
- 内存消耗 :41 MB, 在所有 Java 提交中击败了16.67%的用户
- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度：所有节点都被遍历到 O(N)
<br/>&emsp;&emsp;空间复杂度：使用Node遍历了所有节点，即O(N)

## 题解2 C的递归解法

- 执行结果：通过
- 执行用时 :12 ms, 在所有 C 提交中击败了92.36%的用户
- 内存消耗 :9.4 MB, 在所有 C 提交中击败了100.00%的用户
- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度：所有节点都被遍历到 O(N)
<br/>&emsp;&emsp;空间复杂度：使用Node遍历了所有节点，即O(N)

## 题解3 C的非递归解法

- 执行结果：通过
- 执行用时 :20 ms, 在所有 C 提交中击败了36.94%的用户
- 内存消耗 :10  MB, 在所有 C 提交中击败了100.00%的用户
- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度：所有节点都被遍历到 O(N)
<br/>&emsp;&emsp;空间复杂度：使用Node遍历了所有节点，即O(N)
