# 102. 二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
二叉树：[3,9,20,null,null,15,7],

```a
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```a
[
  [3],
  [9,20],
  [15,7]
]
```

通过次数&ensp;107,907&ensp;&ensp;提交次数&ensp;175,195。

## 题解1 C BFS

&ensp;&ensp;用两个索引和数组模拟队列&ensp;&ensp;每一层判段队列不为空&ensp;&ensp;BFS遍历每一层

- 执行结果：通过
- 执行用时 :4 ms, 在所有 C 提交中击败了96.00%的用户
- 内存消耗 :7.2 MB, 在所有 C 提交中击败了100.00%的用户
- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度:O(n)
<br/>&emsp;&emsp;空间复杂度:O(n)

## 题解2 迭代实现 Java BFS

迭代实现
广度优先遍历是按层层推进的方式，遍历每一层的节点。题目要求的是返回每一层的节点值，所以这题用广度优先来做非常合适。
广度优先需要用队列作为辅助结构，我们先将根节点放到队列中，然后不断遍历队列。

- 执行结果：通过
- 执行用时 :1 ms, 在所有 Java 提交中击败了92.55%的用户
- 内存消耗 :40.2 MB, 在所有 Java 提交中击败了5.71%的用户
- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度:O(n)
<br/>&emsp;&emsp;空间复杂度:O(n)

## 题解3 递归实现 Java DFS

用广度优先处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。

```a
       1
    /     \
   2       5
 /   \   /   \
3     4 6     7
```

我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个list。

```a
1
|
2   5
|   |   |
3   4   6   7
```

按照深度优先的处理顺序，会先访问节点1，再访问节点2，接着是节点3。之后是第二列的4和5，最后是第三列的6。每次递归的时候都需要带一个index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的list不存在，就加入一个空list进去。

- 复杂度分析：
<br/>&emsp;&emsp;时间复杂度:O(n)
<br/>&emsp;&emsp;空间复杂度:O(h)，h是树的高度
